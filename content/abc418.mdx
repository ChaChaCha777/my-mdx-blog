---
title: ABC418
tags: 
    - 累積和
    - 二分探索
date: 2025-08-12
---

## 問題文
$N$種類のフレーバーのティーバッグがある。フレーバー$i(1\leq i\leq N)$ のティーバッグは$A_i$個ある。

あなたはこれらのティーバッグを使ったゲームに参加する。ゲームには$1$以上$A_1+\dots+A_N$以下の難易度が設定されており，難易度$b$のゲームは以下の流れで行われる。

- あなたは$b\leq x\leq A_1+\dots+A_N$を満たす整数$x$を宣言する。
- ディーラーはティーバッグの中からちょうど$x$個を選び、あなたに渡す。
- あなたは渡された$x$個のティーバッグのフレーバーを確認し、その中から$b$個のティーバッグを選ぶ。
- あなたが選んだ$b$個のティーバッグがすべて同じフレーバーであれば、あなたは勝利する。そうでなければ、あなたは敗北する。
- ディーラーはあなたが敗北するように最善を尽くすものとする。

$Q$個の質問が与えられるので、それぞれに答えよ。$j$番目の質問は以下の通り。

難易度$B_j$のゲームに勝利するためにはじめに宣言する必要がある整数$x$の最小値を答えよ。勝利が不可能であれば、代わりに $−1$と答えよ。

## 制約
- $1\leq N, Q \leq 3\times 10^5$

## 考察
次のように、ディーラーの立場になって考えるとわかりやすい。ディーラーが1つずつティーバッグを取り出す。次にディーラーがティーバッグを取り出したら確実に勝てる時点でストップする。ディーラーがそれまでに取り出したティーバッグの個数に1を足したものが、難易度$b$のゲームに対して宣言すべき最小の整数$x$である。

$b$が$A$の最大値よりも大きければディーラーに勝つことはできない。以下では、そうでないときを考える。

ディーラーは相手が敗北するように最善を尽くすので、同じフレーバーのティーバッグが$b-1$個を超えないようにティーバッグを取り出す。そのため、最小の$x$は
$$
x = 1 + \sum_{i=1}^{N}\min(b-1, A_{i})
$$
となる。

$Q$個のクエリについて、この$x$を普通に評価すると、計算量は$\mathrm{O}(NQ)$となり、TLEとなるから、計算を工夫する必要がある。

$A_{i}$の順番に意味はないので、$A_{i}$を昇順にソートしたものを改めて$A_{i}$とおく。すると、ある$i(b)$が存在して

- $1\leq i\leq i(b)$ならば$\min(b-1, A_{i}) = A_i$
- $i(b)< i\leq N$ならば$\min(b-1, A_{i}) = b-1$

が成り立つ。結局最小の$x$は

$$
x = 1 + (N-i(b))(b-1) + \sum_{i=1}^{i(b)}A_{i}
$$
で計算できる。$i(b)$は二分探索で求められ、計算量は$\mathrm{O}(\log N)$。さらに、$A_{i}$の累積和をあらかじめ計算しておけば、和の項も高速に計算可能である。最終的な計算量は$\mathrm{O}(N+Q\log N)$となる。


実装の注意点として、累積和のインデックスは1から始めた。その方がコードはすっきりとした。
```python
import bisect

N, Q = map(int, input().split())

A = list(map(int, input().split()))

A = sorted(A)

# 累積和を求める
cum_sum = [0]
for i in range(N):
    cum_sum.append(cum_sum[-1] + A[i])

# クエリに答える
for i in range(Q):
    b = int(input())

    if ( b > A[-1]):
        print(-1)
    else:
        ib = bisect.bisect_right(A, b - 1) 
        print(1 + (N - ib) * (b - 1) + cum_sum[ib]) 
        # 累積和のインデックスは1から始まることに注意。
```
