---
title: ABC426
date: 2025-10-09
tags: 
    - atcoder
---

## 問題文
あるOSのバージョンは$N$個あり、古い順に $1,2,\dots,N$の番号がついている。PCが$N$台あり、初めは$i$番目のPCのOSのバージョンは$i$である。

$Q$回の操作を順に行いなさい。$i$回目の操作は次のように行う。

現時点でのOSのバージョンが$X_i$かそれ以前のPCすべてのバージョンを$Y_i(>X_i)$にアップグレードする。その後、この操作でアップグレードを行った PC の台数を出力する。

## 制約
- $2\leq N\leq 10^6$
- $1\leq Q\leq 2×10^5$

## 考察
バージョンの分布を何も工夫せずに管理したシミュレーションを行うと、計算量が$O(NQ)$となり、TLEする。そこで、分布がいつも、あるバージョンまではカウントが0であることを利用する。ここまでは個数が0だ、というカウントをオフセットとして管理する。$i$回目のクエリにおいて$X_i$がオフセット以下であれば何もする必要はない。もし$X_i$がオフセットより大きければシミュレートによってアップグレードされたPCの個数を出力する。この場合の計算量は$O(Q+N)$となる。$O(N)$が出てくるのは、コードを見た方がわかりやすいかもしれない。大雑把な式で示すと次のようになる。オフセットはクエリが進むにしたがって階段上に増えていく。各オフセットを$ \mathrm{offset}_1,\mathrm{offset}_2,\dots,\mathrm{offset}_m $とすると、シミュレートに必要な繰り返し回数は$\sum_{i=1}^{m-1}(\mathrm{offset}_{i+1}-\mathrm{offset}_{i})=\mathrm{offset}_m - \mathrm{offset}_1 = O(N)$である。

```python
N, Q = map(int, input().split())

# versionは0-indexed
version_dist = [1 for i in range(N + 1)]
version_dist[0] = 0

# version = offset までは0
offset = 0
for i in range(Q):
    X, Y = map(int, input().split())

    if X > offset:

        # シミュレート
        upgrade_count = 0
        for i in range(offset+1, X+1):
            upgrade_count += version_dist[i]

        print(upgrade_count)
        version_dist[Y] += upgrade_count
        offset = X

    else:
        print(0)

```

